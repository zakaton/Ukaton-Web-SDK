<html>
  <head>
    <title>Ukaton Side Missions | Machine Learning</title>
    <link
      rel="icon"
      href="https://cdn.glitch.com/024019a9-317f-4462-b4f9-7674047a399c%2Fukaton_no_text_low.png?v=1595095184886"
    />

    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r118/three.min.js"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>

    <script src="/SideMission.js"></script>

    <script src="https://unpkg.com/js-untar@2.0.0/build/dist/untar.js"></script>
    <script src="https://unpkg.com/pako@2.0.3/dist/pako.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>

    <script
      src="https://unpkg.com/ml5@latest/dist/ml5.min.js"
      type="text/javascript"
    ></script>
  </head>

  <style>
    label {
      display: block;
      user-select: none;
    }

    iframe {
      margin: auto;
      display: block;
    }

    [data-results] h1 {
      font-size: 70;
    }

    input[type="number"] {
      width: 100px;
    }

    a-scene {
      width: 200px;
      height: 200px;
    }

    .connection.hide {
      display: none;
    }
    .connection:not(.connected) .connected {
      display: none;
    }
  </style>

  <body>
    <h1>
      Ukaton Side Mission | Machine Learning
    </h1>

    <hr />

    <div id="numberOfSideMissions">
      <h2>
        Number of Side Missions
      </h2>

      <label>
        number of side missions:
        <input
          type="number"
          min="1"
          step="1"
          value="1"
          oninput="onInputNumberOfSideMissions(event)"
        />
      </label>
    </div>

    <hr />

    <div id="iframes">
      <template>
        <div>
          <h2 class="index">
            1
          </h2>
          <iframe src="/visualization" width="90%" height="500"></iframe>
        </div>
      </template>
    </div>

    <hr />

    <div id="options" data-type="task">
      <h2>Options</h2>

      <label id="task">
        Task:
        <select data-options oninput="onSelectTask(event)">
          <optgroup label="Task">
            <option value="classification">Classification</option>
            <option value="regression">Regression</option>
          </optgroup>
        </select>
      </label>

      <hr />

      <div id="inputs">
        <h3>
          Inputs
        </h3>

        <label data-input="acceleration">
          Acceleration
          <input type="checkbox" oninput="onToggleInput(event)" data-options />
        </label>
        <label data-input="gravity">
          Gravity
          <input type="checkbox" oninput="onToggleInput(event)" data-options />
        </label>
        <label data-input="linearAcceleration">
          Linear Acceleration
          <input type="checkbox" oninput="onToggleInput(event)" data-options />
        </label>
        <label data-input="rotationRate">
          Rotation Rate
          <input type="checkbox" oninput="onToggleInput(event)" data-options />
        </label>
        <label data-input="magnetometer">
          Magnetometer
          <input type="checkbox" oninput="onToggleInput(event)" data-options />
        </label>
        <label data-input="quaternion">
          Quaternion
          <input type="checkbox" oninput="onToggleInput(event)" data-options />
        </label>
        <label data-input="euler">
          Euler
          <input type="checkbox" oninput="onToggleInput(event)" data-options />
        </label>
      </div>

      <hr />

      <div id="outputs">
        <h3>
          Outputs
        </h3>

        <label id="numberOfOutputs">
          Number of Outputs:
          <input
            type="number"
            step="1"
            min="1"
            value="1"
            oninput="onInputNumberOfOutputs(event)"
            data-options
          />
        </label>

        <div class="outputs">
          <template>
            <div class="output">
              <input
                type="string"
                data-name
                placeholder="output label"
                data-options
              />:
              <input
                type="number"
                value="0"
                min="0"
                max="1"
                step="1"
                data-value
              />
            </div>
          </template>
        </div>
      </div>

      <hr />

      <div id="Sampling">
        <h3>
          Sampling
        </h3>

        <label data-number-of-samples>
          Number of Samples:
          <input
            type="number"
            min="1"
            value="1"
            step="1"
            data-options
            oninput="onInputNumberOfSamples(event)"
          />
        </label>

        <label data-sampling-period>
          Sampling Period (ms):
          <input
            disabled
            type="number"
            value="0"
            min="0"
            step="20"
            data-options
          />
        </label>

        <label data-sampling-rate>
          Sampling Rate (ms)
          <input
            type="number"
            value="40"
            min="20"
            max="1000"
            step="20"
            data-options
            oninput="onInputSamplingRate(event)"
          />
        </label>
      </div>

      <hr />

      <div id="create">
        <h3>
          Create Neural Network
        </h3>

        <button onclick="onClickCreateNeuralNetwork(event)">
          Create
        </button>
      </div>

      <hr />

      <div id="addingData">
        <h3>
          Add Data
        </h3>

        <button data-add disabled onclick="onClickAddData(event)">
          Add Data
        </button>

        <label>
          Continuous:
          <input
            data-add
            disabled
            type="checkbox"
            oninput="onToggleAddDataContinuously(event)"
          />
        </label>
      </div>

      <hr />

      <div id="train">
        <h3>
          Train Neural Network
        </h3>

        <button data-train disabled onclick="onClickTrain(event)">
          Train
        </button>
      </div>

      <hr />

      <div id="results">
        <h3>
          Classify & Predict
        </h3>

        <button onclick="onClickTest()" disabled data-test>Test</button>
        <label>
          Test Continuously
          <input
            data-test
            type="checkbox"
            disabled
            onclick="onToggleTestContinuously(event)"
          />
        </label>

        <div>
          <h4>
            Results
          </h4>

          <div data-results></div>
        </div>
      </div>

      <hr />

      <div id="save">
        <h3>
          Save
        </h3>

        <button data-save disabled onclick="onClickSaveData(event)">
          Save Data
        </button>

        <button data-save disabled onclick="onClickSaveModel(event)">
          Save Model
        </button>
      </div>

      <hr />

      <div id="load">
        <h3>
          Load
        </h3>

        <label>
          Load Data
          <input
            disabled
            data-load
            type="file"
            accept=".json"
            oninput="onInputLoadData(event)"
          />
        </label>

        <label>
          Load Model
          <input
            disabled
            data-load
            type="file"
            multiple
            accept=".json,.bin"
            oninput="onInputLoadModel(event)"
          />
        </label>
      </div>
    </div>
  </body>

  <script>
    if (location.protocol != "https:") {
      location.replace(
        `https:${location.href.substring(location.protocol.length)}`
      );
    }

    let iframes = [];
    const iframePool = [];
    let sideMissions = [];
    const sideMissionPool = [];
    function setNumberOfSideMissions(numberOfSideMissions) {
      if (iframePool.length < numberOfSideMissions) {
        while (iframePool.length < numberOfSideMissions) {
          const container = document
            .querySelector("#iframes template")
            .content.cloneNode(true)
            .querySelector("div");
          const iframe = container.querySelector("iframe");
          iframePool.push(iframe);
          const index = iframePool.indexOf(iframe);
          container.querySelector(".index").innerText = index + 1;
          iframe.addEventListener("load", event => {
            const sideMission = iframe.contentWindow.sideMission;
            sideMissionPool[index] = sideMission;
            iframe.contentDocument
              .querySelectorAll("input")
              .forEach(input => (input.disabled = true));
            let allIframesHaveLoaded = true;
            for (
              let i = 0;
              i < numberOfSideMissions && !allIframesHaveLoaded;
              i++
            ) {
              allIframesHaveLoaded = sideMissionPool[i];
            }
            if (allIframesHaveLoaded) {
              sideMissions = sideMissionPool.slice(0, numberOfSideMissions);
            }
          });
          document.getElementById("iframes").appendChild(container);
        }
      } else {
        sideMissions = sideMissionPool.slice(0, numberOfSideMissions);
      }

      iframes = iframePool.slice(0, numberOfSideMissions);
      iframePool.forEach(iframe => {
        iframe.closest("div").style.display = iframes.includes(iframe)
          ? ""
          : "none";
      });
    }
    setNumberOfSideMissions(1);
    function onInputNumberOfSideMissions(event) {
      setNumberOfSideMissions(Number(event.target.value));
    }

    let task = "classification";
    function onSelectTask(event) {
      task = event.target.value;
      console.log(`changing task to ${task}`);
      document
        .querySelectorAll(`#outputs .outputs .output input`)
        .forEach(input => {
          formatOutputs();
        });
    }

    function formatOutputs() {
      const outputElements = Array.from(
        document.querySelectorAll("#outputs .outputs .output")
      );
      outputElements.forEach(outputElement => {
        const value = outputElement.querySelector("[data-value]");
        if (task == "classification") {
          value.setAttribute("value", 0);
          value.setAttribute("min", 0);
          value.setAttribute("max", 1);
          value.setAttribute("step", 1);
        } else {
          value.removeAttribute("min");
          value.removeAttribute("max");
          value.removeAttribute("step");
        }
      });
    }

    let outputs;
    function getOutputs() {
      const outputElements = Array.from(
        document.querySelectorAll("#outputs .outputs .output")
      );

      const _outputs = outputElements.map(
        outputElement => outputElement.querySelector("[data-name]").value
      );

      if (_outputs.length) {
        outputs = _outputs;
      }
      return _outputs;
    }
    function getOutputValues() {
      let outputValues = Array.from(
        document.querySelectorAll("#outputs .outputs .output [data-value]")
      ).map(input => {
        let value = Number(input.value);
        return value;
      });

      if (task == "classification") {
        outputValues = outputValues.reduce(
          (_outputValues, outputValue, index) => {
            if (outputValue) {
              _outputValues.push(outputs[index]);
            }
            return _outputValues;
          },
          []
        );
      } else {
        outputValues = outputValues.reduce(
          (_outputValues, outputValue, index) => {
            _outputValues[outputs[index]] = outputValue;
            return _outputValues;
          },
          {}
        );
      }

      return outputValues;
    }

    let inputs = [];
    function onToggleInput(event) {
      const { input } = event.target.closest("[data-input]").dataset;
      if (event.target.checked) {
        if (!inputs.includes(input)) {
          console.log(`adding input ${input}`);

          inputs.push(input);
        }
      } else {
        if (inputs.includes(input)) {
          console.log(`removing input ${input}`);

          inputs.splice(inputs.indexOf(input), 1);
        }
      }
      console.log("current inputs:", inputs);
    }
    document
      .querySelectorAll("[checked]")
      .forEach(input => input.dispatchEvent(new Event("input")));

    let numberOfOutputs = 0;

    const numberOfOutputsInput = document.querySelector(
      "#numberOfOutputs input"
    );
    function onInputNumberOfOutputs(event) {
      numberOfOutputs = Number(event.target.value);
      console.log(`changed number of outputs to ${numberOfOutputs}`);
      const outputElements = Array.from(
        document.querySelectorAll(`#outputs .output`)
      );
      if (outputElements.length !== numberOfOutputs) {
        if (outputElements.length > numberOfOutputs) {
          outputElements
            .slice(numberOfOutputs)
            .forEach(output => output.remove());
        } else {
          for (
            let index = 0;
            index < numberOfOutputs - outputElements.length;
            index++
          ) {
            const output = document
              .querySelector("#outputs .outputs template")
              .content.cloneNode(true)
              .querySelector(".output");
            document.querySelector("#outputs .outputs").appendChild(output);
            const name = output.querySelector("[data-name]");

            name.value = `output${index + outputElements.length}`;
          }
          formatOutputs();
        }
      }
    }
    numberOfOutputsInput.dispatchEvent(new Event("input"));

    // SAMPLING
    const numberOfSamplesInput = document.querySelector(
      "#sampling [data-number-of-samples] input"
    );
    const samplingPeriodInput = document.querySelector(
      "#sampling [data-sampling-period] input"
    );
    const samplingRateInput = document.querySelector(
      "#sampling [data-sampling-rate] input"
    );

    let numberOfSamples = Number(numberOfSamplesInput.value);
    let samplingPeriod = Number(samplingPeriodInput.value);
    let samplingRate = Number(samplingRateInput.value);

    function updateSamplingPeriod() {
      samplingPeriod = (numberOfSamples - 1) * samplingRate;
      samplingPeriodInput.value = samplingPeriod;

      console.log(`changed sampling period to ${samplingPeriod}`);
    }

    function onInputNumberOfSamples(event) {
      numberOfSamples = Number(event.target.value);
      console.log(`changed number of samples to ${numberOfSamples}`);

      updateSamplingPeriod();
    }

    function onInputSamplingRate(event) {
      samplingRate = Number(event.target.value);
      console.log(`changed sampling rate to ${samplingRate}`);

      samplingPeriodInput.step = samplingRate;

      updateSamplingPeriod();
    }

    /* global ml5 */
    let neuralNetwork;
    function onClickCreateNeuralNetwork(event) {
      const outputs = getOutputs();
      if (
        inputs.length && outputs.length > (task === "classification")
          ? 1
          : 0 && sideMission.isConnected
      ) {
        const imuConfiguration = {};
        inputs.forEach(imuDataType => {
          imuConfiguration[imuDataType] = samplingRate;
        });
        sideMissions.forEach(sideMission => {
          sideMission.configureImu(imuConfiguration);
        });

        neuralNetwork = ml5.neuralNetwork({
          task,

          inputs: getNumberOfInputs(),
          outputs,

          debug: true,

          learningRate: 0.08,
          hiddenUnits: 72
        });

        event.target.disabled = true;
        document
          .querySelectorAll("[data-options]")
          .forEach(input => (input.disabled = true));

        document
          .querySelectorAll("[data-add]")
          .forEach(input => (input.disabled = false));
        document
          .querySelectorAll("[data-train]")
          .forEach(input => (input.disabled = false));

        document
          .querySelectorAll("[data-save]")
          .forEach(input => (input.disabled = false));

        document
          .querySelectorAll("[data-load]")
          .forEach(input => (input.disabled = false));

        console.log("created neural network", neuralNetwork);
      }
    }

    let inputCounts = {
      acceleration: 3,
      gravity: 3,
      linearAcceleration: 3,
      rotationRate: 3,
      magnetometer: 3,
      quaternion: 4,
      euler: 3
    };
    function getNumberOfInputs() {
      let numberOfInputs = 0;
      for (const input in inputCounts) {
        if (inputs.includes(input)) {
          numberOfInputs += inputCounts[input];
        }
      }
      numberOfInputs *= numberOfSamples;
      numberOfInputs *= sideMissions.length;
      return numberOfInputs;
    }

    function includesAny(a, ...b) {
      return b.some(_ => a.includes(_));
    }

    let isAddingData = false;
    function onClickAddData(event) {
      if (!isAddingData) {
        addData();
      }
    }

    let addDataButton = document.querySelector("[data-add]");
    function addData() {
      if (!isAddingData) {
        const outputs = getOutputValues();
        console.log("Adding data");
        isAddingData = true;
        addDataButton.disabled = true;
        addDataButton.innerText = "collecting data";
        collectData(data => {
          data.forEach((value, index) => {
            if (!value) {
              data[index] = 0.000001 * Math.random();
            }
          });
          console.log("got data", data, outputs);

          neuralNetwork.addData(data, outputs);
          isAddingData = false;
          if (addDataContinuously) {
            addData();
          } else {
            addDataButton.innerText = "Add Data";
            addDataButton.disabled = false;
          }
        });
      }
    }

    let addDataContinuously = false;
    function onToggleAddDataContinuously(event) {
      addDataContinuously = event.target.checked;
    }

    function collectData(callback) {
      const sideMissionsDatum = sideMissions.map(() => []); // [[{timestamp, [type]: value, isComplete: true|false}]]

      const checkData = data => {
        if (inputs.every(input => input in data)) {
          data.isComplete = true;
        }

        const hasCollectedAllData = sideMissionsDatum.every(
          sideMissionDatum => {
            return (
              sideMissionDatum.filter(data => data.isComplete).length >=
              numberOfSamples
            );
          }
        );
        if (hasCollectedAllData) {
          onCollectedData();
        }
      };

      const onCollectedData = () => {
        console.log(sideMissionsDatum);
        sideMissionsDatum.map(sideMissionDatum => sideMissionDatum.filter(data => data.isComplete).sort((a, b) => a.timestamp - b.timestamp))
        const data = sideMissionsDatum.flatMap(sideMissionDatum => sideMissionDatum.slice(0, numberOfSamples).flatMap(data => inputs.flatMap(input => data[input])));
        callback(data);
        sideMissions.forEach((sideMission, index) => {
          for (const input in eventListeners[index]) {
            sideMission.removeEventListener(
              input,
              eventListeners[index][input]
            );
          }
        });
      };

      const eventListeners = []; // [{type: eventListener}]
      sideMissions.forEach((sideMission, index) => {
        eventListeners[index] = {}
        inputs.forEach(input => {
          eventListeners[index][input] = event => {
            const { timestamp } = event.message;
            const sideMissionDatum = sideMissionsDatum[index];

            const data = sideMissionDatum.find(data => data.timestamp == timestamp) || {
              timestamp
            };
            if (!sideMissionDatum.includes(data)) {
              sideMissionDatum.push(data);
            }

            const value = event.message[input];
            const array = value.toArray();
            if (value.isEuler) {
              array.pop();
            }
            data[input] = array;
            checkData(data);
          };
          sideMission.addEventListener(input, eventListeners[index][input]);
        });
      });
    }

    let overlapMinimum = 250;
    let overlaps = 1;
    let overlap = 250;
    function onClickTrain(event) {
      if (neuralNetwork) {
        neuralNetwork.normalizeData();
        neuralNetwork.train(
          {
            batchSize: 16,
            epochs: 32
          },
          () => {
            console.log("done training");
            event.target.disabled = true;
            document
              .querySelectorAll("[data-test]")
              .forEach(input => (input.disabled = false));
            test();

            if (samplingPeriod >= 2 * overlapMinimum) {
              overlaps = Math.floor(samplingPeriod / overlapMinimum);
              overlap = Math.floor(samplingPeriod / overlaps);
              for (let index = 0; index < overlaps; index++) {
                setTimeout(() => {
                  test();
                }, overlap);
              }
            }
          }
        );
      }
    }

    function onClickTest() {
      test();
    }

    let testContinuously = false;
    function onToggleTestContinuously(event) {
      testContinuously = event.target.checked;
    }

    function test() {
      if (neuralNetwork) {
        collectData(data => {
          console.log("collected data", data);
          if (task == "classification") {
            neuralNetwork.classify(data, handleResults);
          } else {
            neuralNetwork.predict(data, handleResults);
          }
        });
      }
    }
    function handleResults(error, results) {
      if (error) {
        console.error(error);
      } else {
        console.log(results);
        const resultsContainer = document.querySelector("[data-results]");
        resultsContainer.innerHTML = "";
        results.forEach(result => {
          const { label } = result;
          let string = `label: ${label}, `;
          if (task == "classification") {
            string += `value: ${result[label].toFixed(
              3
            )}, confidence: ${result.confidence.toFixed(3)},`;
          } else {
            const { value } = result;
            string += `value: ${value.toFixed(3)}`;
          }
          resultsContainer.innerText += `${string}\n`;
        });

        resultsContainer.innerHTML += `<h1>${results[0].label} ${
          task == "regression" ? results[0].value.toFixed(4) : ""
        }</h1>`;

        if (testContinuously) {
          test();
        }
      }
    }

    function onClickSaveData() {
      if (neuralNetwork) {
        console.log("saving data");
        neuralNetwork.saveData();
      }
    }
    function onClickSaveModel() {
      if (neuralNetwork) {
        console.log("saving model");
        neuralNetwork.save();
      }
    }

    function onInputLoadData(event) {
      if (neuralNetwork) {
        console.log("loading data");
        console.log(event.target.files);
        neuralNetwork.loadData(event.target.files, () => {
          console.log("loaded data");
        });
      }
    }

    function onInputLoadModel(event) {
      if (neuralNetwork) {
        console.log("loading model");
        neuralNetwork.load(event.target.files, () => {
          console.log("loaded model");
        });
      }
    }

    // returns (model.weights.bin, model.json)
    function getModel(callback) {
      if (
        sideMissions.length == 1 &&
        neuralNetwork &&
        neuralNetwork.neuralNetwork.isTrained
      ) {
        neuralNetwork.neuralNetwork.model.save(
          ml5.tf.io.withSaveHandler(async data => {
            const weightsManifest = {
              modelTopology: data.modelTopology,
              weightsManifest: [
                {
                  paths: [`./model.weights.bin`],
                  weights: data.weightSpecs
                }
              ]
            };
            callback(data.weightData, weightsManifest);
          })
        );
      }
    }

    const { seedrandom } = Math;
    const SEED = "Hello";

    function shuffleData(inputs, outputs) {
      const rand = seedrandom(SEED);

      const indexes = inputs.map((_, i) => i);
      indexes.sort(() => rand() - 0.5);

      const shuffledInputs = [];
      const shuffledOutputs = [];

      indexes.forEach((i, j) => {
        shuffledInputs[j] = inputs[i];
        shuffledOutputs[j] = outputs[i];
      });

      return [shuffledInputs, shuffledOutputs];
    }

    function splitArray(data, fract) {
      const splitPoint = Math.round(data.length * fract);
      const a = data.slice(0, splitPoint);
      const b = data.slice(splitPoint, data.length);
      return [a, b];
    }

    function shuffleAndSplitDataSet([X, Y], splitRatio = 0.8) {
      const [shuffled_X, shuffled_Y] = shuffleData(X, Y);
      const [train_X, test_X] = splitArray(shuffled_X, splitRatio);
      const [train_Y, test_Y] = splitArray(shuffled_Y, splitRatio);

      return [train_X, train_Y, test_X, test_Y];
    }

    function rescale(minIn, maxIn, minOut, maxOut, [X, Y]) {
      const rescaledX = [];
      const a = minOut - minIn;
      const scaleRatio = (maxOut - minOut) / (maxIn - minIn);

      X.forEach(row => {
        rescaledX.push(row.map(v => (v + a) * scaleRatio));
      });
      return [rescaledX, Y];
    }

    function prepareDataSet() {
      const inputs = [];
      const outputs = [];

      neuralNetwork.data.training.forEach(({ xs, ys }, index) => {
        const input = [];
        for (const key in xs) {
          input.push(xs[key]);
        }
        inputs.push(input);

        const output = [];
        for (const key in ys) {
          const value = ys[key];
          if (value instanceof Array) {
            output.push(...ys[key]);
          } else {
            output.push(ys[key]);
          }
        }
        outputs.push(output);
      });

      return [inputs, outputs];
    }

    let trainTestSplit = 0.2;
    function sendModel(quantize = false) {
      if (neuralNetwork && neuralNetwork.neuralNetwork.isTrained) {
        neuralNetwork.neuralNetwork.model
          .save(
            ml5.tf.io.browserHTTPRequest(
              `https://tfjs-to-tflite.zakaton.repl.co/convert?${
                quantize ? "quantize=true" : ""
              }`,
              {
                fetchFunc: (url, req) => {
                  if (quantize) {
                    const [, , test_x] = shuffleAndSplitDataSet(
                      prepareDataSet(),
                      1 - trainTestSplit
                    );
                    req.body.append("quantize_data", JSON.stringify(test_x));
                  }

                  return fetch(url, req);
                }
              }
            )
          )
          .then(result => {
            console.log(result);
            const res = result.responses[0];
            res
              .arrayBuffer() // Download gzipped tar file and get ArrayBuffer
              .then(pako.inflate) // Decompress gzip using pako
              .then(arr => arr.buffer) // Get ArrayBuffer from the Uint8Array pako returns
              .then(untar) // Untar
              .then(files => {
                // js-untar returns a list of files (See https://github.com/InvokIT/js-untar#file-object for details)
                console.log(files);
                const model_h = files.find(file => file.name === "model.h");
                const model_tflite = files.find(
                  file => file.name === "model.tflite"
                );
                console.log(model_h, model_tflite);
              });
          })
          .catch(error => console.log(error));
      }
    }

    function downloadBlob(blob, fileName) {
      const a = document.createElement("a");
      document.body.appendChild(a);
      a.style = "display: none";
      const url = window.URL.createObjectURL(blob);
      a.href = url;
      a.download = fileName;
      a.click();
      window.URL.revokeObjectURL(url);
    }
  </script>
</html>
